<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rocket Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght:700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: linear-gradient(to bottom, #000814 0%, #001d3d 50%, #003566 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 3px solid #ffc300;
            box-shadow: 0 0 30px rgba(255, 195, 0, 0.4), inset 0 0 50px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to bottom, #000428 0%, #004e92 100%);
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffc300;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 195, 0, 0.8), 0 0 20px rgba(255, 195, 0, 0.4);
            z-index: 10;
        }

        #launchSequence {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #ff006e;
            text-shadow: 0 0 20px rgba(255, 0, 110, 0.8), 0 0 40px rgba(255, 0, 110, 0.5);
            z-index: 100;
            display: none;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00b4d8;
            font-size: 16px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 180, 216, 0.8);
            z-index: 10;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 3px solid #ff006e;
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.6);
            color: #ffc300;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            display: none;
            z-index: 200;
        }

        #gameOver h2 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 195, 0, 0.8);
        }

        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
        }

        #gameOver button {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.5);
            transition: all 0.3s;
        }

        #gameOver button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.8);
        }

        #rocketSelection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #ffc300;
            box-shadow: 0 0 30px rgba(255, 195, 0, 0.6);
            color: #ffc300;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            z-index: 300;
            max-width: 900px;
        }

        #rocketSelection h2 {
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 195, 0, 0.8);
        }

        #rocketGrid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .rocket-option {
            background: linear-gradient(135deg, #001d3d, #003566);
            border: 2px solid #00b4d8;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .rocket-option:hover {
            transform: scale(1.05);
            border-color: #ffc300;
            box-shadow: 0 0 20px rgba(255, 195, 0, 0.5);
        }

        .rocket-option.selected {
            border-color: #ff006e;
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.8);
        }

        .rocket-preview {
            width: 100%;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .rocket-name {
            font-size: 12px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .rocket-stats {
            font-size: 10px;
            color: #00b4d8;
        }

        #startButton {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            padding: 15px 50px;
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.5);
            transition: all 0.3s;
            margin-top: 30px;
        }

        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.8);
        }

        #startButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #raceResults {
            background: rgba(0, 29, 61, 0.5);
            padding: 15px;
            border: 1px solid #00b4d8;
            margin-top: 20px;
        }

        #resultsTable {
            font-family: 'Share Tech Mono', monospace;
        }

        .result-row {
            padding: 5px;
            border-bottom: 1px solid rgba(0, 180, 216, 0.3);
            display: flex;
            justify-content: space-between;
        }

        .result-row.player {
            background: rgba(255, 195, 0, 0.2);
            border: 1px solid #ffc300;
            font-weight: bold;
        }

        .result-row.crashed {
            color: #ff006e;
            opacity: 0.7;
        }

        .result-row.finished {
            color: #06ffa5;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>ALTITUDE: <span id="altitude">0</span>m / <span id="targetAltitude">5000</span>m</div>
        <div>SPEED: <span id="speed">0</span>m/s</div>
        <div>FUEL: <span id="fuel">100</span>%</div>
        <div>POSITION: <span id="position">21</span> / 21</div>
        <div style="margin-top: 10px; font-size: 14px;">ALIVE: <span id="aliveCount">21</span></div>
    </div>

    <div id="launchSequence">PRESS ENTER!</div>
    <div id="instructions">Launch: Press ENTER 3 times | Navigate: Arrow Keys or WASD | Avoid Obstacles!</div>

    <canvas id="gameCanvas" width="1200" height="600"></canvas>

    <div id="rocketSelection">
        <h2>SELECT YOUR ROCKET</h2>
        <div id="rocketGrid"></div>
    </div>

    <div id="gameOver">
        <h2 id="gameOverTitle">MISSION COMPLETE!</h2>
        <p id="gameOverStatus"></p>
        <p>Final Position: <span id="rank">0</span> / 21</p>
        <p>Distance: <span id="finalDistance">0</span>m</p>
        <div id="raceResults" style="margin-top: 20px; max-height: 200px; overflow-y: auto; font-size: 14px; text-align: left;">
            <h3 style="text-align: center; margin-bottom: 10px;">RACE RESULTS</h3>
            <div id="resultsTable"></div>
        </div>
        <button onclick="location.reload()">RACE AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Create starfield background
        for (let i = 0; i < 50; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            star.style.width = star.style.height = Math.random() * 3 + 'px';
            star.style.animationDelay = Math.random() * 2 + 's';
            document.body.appendChild(star);
        }

        // Rocket types with unique designs
        const rocketTypes = [
            { name: 'FALCON', speed: 3.5, fuel: 100, color: '#e0e0e0', accent: '#ff006e', design: 'sleek' },
            { name: 'ATLAS', speed: 3, fuel: 120, color: '#c0c0c0', accent: '#00b4d8', design: 'heavy' },
            { name: 'DELTA', speed: 4, fuel: 90, color: '#ffffff', accent: '#ffc300', design: 'racing' },
            { name: 'TITAN', speed: 2.5, fuel: 150, color: '#a0a0a0', accent: '#8338ec', design: 'cargo' },
            { name: 'ARIANE', speed: 3.2, fuel: 110, color: '#d0d0d0', accent: '#06ffa5', design: 'euro' },
            { name: 'SOYUZ', speed: 3.8, fuel: 95, color: '#b0b0b0', accent: '#ff4500', design: 'classic' },
            { name: 'SATURN', speed: 2.8, fuel: 140, color: '#f0f0f0', accent: '#4cc9f0', design: 'apollo' },
            { name: 'ANTARES', speed: 3.6, fuel: 100, color: '#e5e5e5', accent: '#7209b7', design: 'modern' },
            { name: 'VEGA', speed: 4.2, fuel: 85, color: '#c8c8c8', accent: '#f72585', design: 'compact' },
            { name: 'PROTON', speed: 3.3, fuel: 105, color: '#d5d5d5', accent: '#00f5d4', design: 'soviet' }
        ];

        // Bot personalities
        const personalities = [
            { name: 'Aggressive', dodgeChance: 0.6, speedVariance: 1.2, collisionAvoidance: 0.5 },
            { name: 'Cautious', dodgeChance: 0.9, speedVariance: 0.8, collisionAvoidance: 0.9 },
            { name: 'Balanced', dodgeChance: 0.75, speedVariance: 1.0, collisionAvoidance: 0.7 },
            { name: 'Reckless', dodgeChance: 0.4, speedVariance: 1.3, collisionAvoidance: 0.3 },
            { name: 'Conservative', dodgeChance: 0.85, speedVariance: 0.7, collisionAvoidance: 0.85 }
        ];

        let selectedRocketType = null;
        const TARGET_ALTITUDE = 5000;
        let raceFinished = false;
        let finishOrder = [];

        // Create rocket selection UI
        function createRocketSelection() {
            const grid = document.getElementById('rocketGrid');
            rocketTypes.forEach((type, index) => {
                const option = document.createElement('div');
                option.className = 'rocket-option';
                option.innerHTML = `
                    <div class="rocket-preview">
                        <canvas width="60" height="80" data-rocket="${index}"></canvas>
                    </div>
                    <div class="rocket-name">${type.name}</div>
                    <div class="rocket-stats">Speed: ${type.speed} | Fuel: ${type.fuel}</div>
                `;
                option.onclick = () => selectRocket(index, option);
                grid.appendChild(option);
                
                // Draw preview
                const previewCanvas = option.querySelector('canvas');
                const previewCtx = previewCanvas.getContext('2d');
                drawRocketPreview(previewCtx, 30, 10, type, 0.8);
            });

            const startBtn = document.createElement('button');
            startBtn.id = 'startButton';
            startBtn.textContent = 'START RACE';
            startBtn.disabled = true;
            startBtn.onclick = startGame;
            document.getElementById('rocketSelection').appendChild(startBtn);
        }

        function selectRocket(index, element) {
            document.querySelectorAll('.rocket-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            selectedRocketType = rocketTypes[index];
            document.getElementById('startButton').disabled = false;
        }

        function drawRocketPreview(ctx, x, y, type, scale) {
            const width = 30 * scale;
            const height = 60 * scale;
            
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y + height - 20*scale);
            ctx.lineTo(x - width/2 - 15*scale, y + height);
            ctx.lineTo(x - width/2, y + height);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x + width/2, y + height - 20*scale);
            ctx.lineTo(x + width/2 + 15*scale, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.fill();

            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            ctx.arc(x, y + 20*scale, 8*scale, 0, Math.PI * 2);
            ctx.fill();
        }

        function startGame() {
            document.getElementById('rocketSelection').style.display = 'none';
            gameState = 'launch';
            document.getElementById('targetAltitude').textContent = TARGET_ALTITUDE;
            initializeGame();
        }

        // Game state
        let gameState = 'selection'; // 'selection', 'launch', 'flying', 'gameOver'
        let launchPresses = 0;
        let rocket = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: 30,
            height: 60,
            dx: 0,
            dy: 0,
            speed: 3,
            fuel: 100,
            type: null,
            alive: true,
            distance: 0,
            finished: false,
            finishTime: 0
        };

        let bots = [];
        let obstacles = [];
        let particles = [];
        let launchPads = [];
        let score = 0;
        let altitude = 0;
        let scrollSpeed = 0;
        let obstacleSpawnTimer = 0;
        let backgroundOffset = 0;
        let gameTime = 0;

        function initializeGame() {
            rocket.type = selectedRocketType;
            rocket.speed = selectedRocketType.speed;
            rocket.fuel = selectedRocketType.fuel;
            
            // Create launch pads
            const padSpacing = canvas.width / 21;
            const playerPadIndex = 10; // Middle position
            
            for (let i = 0; i < 21; i++) {
                const x = padSpacing * i + padSpacing / 2;
                launchPads.push({
                    x: x,
                    y: canvas.height - 50,
                    isPlayer: i === playerPadIndex
                });
                
                if (i !== playerPadIndex) {
                    // Create bot with personality
                    const botType = rocketTypes[Math.floor(Math.random() * rocketTypes.length)];
                    const personality = personalities[Math.floor(Math.random() * personalities.length)];
                    
                    bots.push({
                        x: x,
                        y: canvas.height - 100,
                        width: 30,
                        height: 60,
                        speed: botType.speed,
                        fuel: botType.fuel,
                        type: botType,
                        personality: personality,
                        alive: true,
                        distance: 0,
                        finished: false,
                        finishTime: 0,
                        aiTimer: Math.floor(Math.random() * 10), // Start with random offset
                        targetX: x + (Math.random() - 0.5) * 200, // Give them an initial target different from start
                        name: botType.name + ' ' + (i + 1),
                        aggressiveness: Math.random(),
                        velocityX: 0 // Add velocity for smooth movement
                    });
                }
            }
            
            rocket.x = launchPads[playerPadIndex].x;
        }

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === 'Enter' && gameState === 'launch') {
                launchPresses++;
                document.getElementById('launchSequence').style.display = 'block';
                
                if (launchPresses === 1) {
                    document.getElementById('launchSequence').textContent = '3...';
                } else if (launchPresses === 2) {
                    document.getElementById('launchSequence').textContent = '2...';
                } else if (launchPresses === 3) {
                    document.getElementById('launchSequence').textContent = 'LIFTOFF!';
                    setTimeout(() => {
                        gameState = 'flying';
                        scrollSpeed = 2;
                        document.getElementById('launchSequence').style.display = 'none';
                        document.getElementById('instructions').textContent = 'Race to ' + TARGET_ALTITUDE + 'm! | WASD or Arrows to Navigate | Avoid Obstacles & Rockets!';
                    }, 500);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Obstacle class
        class Obstacle {
            constructor(x, y, width, height, type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
            }

            update() {
                this.y += scrollSpeed;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                if (this.type === 'asteroid') {
                    ctx.fillStyle = '#6b5744';
                    ctx.strokeStyle = '#4a3a2a';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    const points = 8;
                    for (let i = 0; i < points; i++) {
                        const angle = (Math.PI * 2 / points) * i;
                        const radius = this.width/2 * (0.8 + Math.sin(i * 3) * 0.2);
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#4a3a2a';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        const x = Math.cos(angle) * this.width/4;
                        const y = Math.sin(angle) * this.width/4;
                        ctx.beginPath();
                        ctx.arc(x, y, this.width/8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'satellite') {
                    ctx.fillStyle = '#c0c0c0';
                    ctx.fillRect(-this.width/2 + 10, -this.height/2, this.width - 20, this.height);
                    
                    ctx.fillStyle = '#1e3a8a';
                    ctx.fillRect(-this.width/2 - 20, -this.height/2, 20, this.height);
                    ctx.fillRect(this.width/2, -this.height/2, 20, this.height);
                    
                    ctx.strokeStyle = '#0f1e47';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < this.height; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 - 20, -this.height/2 + i);
                        ctx.lineTo(-this.width/2, -this.height/2 + i);
                        ctx.moveTo(this.width/2, -this.height/2 + i);
                        ctx.lineTo(this.width/2 + 20, -this.height/2 + i);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#808080';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height/2);
                    ctx.lineTo(0, -this.height/2 - 15);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, -this.height/2 - 15, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'debris') {
                    ctx.fillStyle = '#808080';
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 1;
                    
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, 0);
                    ctx.lineTo(-this.width/4, -this.height/2);
                    ctx.lineTo(this.width/4, -this.height/3);
                    ctx.lineTo(this.width/2, 0);
                    ctx.lineTo(this.width/4, this.height/2);
                    ctx.lineTo(-this.width/3, this.height/3);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'meteoroid') {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                    gradient.addColorStop(0, '#ff6b35');
                    gradient.addColorStop(0.5, '#ffc300');
                    gradient.addColorStop(1, 'rgba(255, 195, 0, 0)');
                    
                    ctx.fillStyle = '#8b7355';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(0, this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Particle class for engine exhaust
        class Particle {
            constructor(x, y, color1 = '#ff6b35', color2 = '#ffc300') {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 8 + 4;
                this.speedY = Math.random() * 3 + 2;
                this.speedX = (Math.random() - 0.5) * 2;
                this.life = 1;
                this.color1 = color1;
                this.color2 = color2;
            }

            update() {
                this.y += this.speedY;
                this.x += this.speedX;
                this.life -= 0.02;
                this.size *= 0.96;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.color1);
                gradient.addColorStop(0.5, this.color2);
                gradient.addColorStop(1, 'rgba(255, 195, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function spawnObstacle() {
            const types = ['asteroid', 'satellite', 'debris', 'meteoroid'];
            const weights = [0.4, 0.2, 0.25, 0.15];
            
            let type;
            const rand = Math.random();
            let sum = 0;
            for (let i = 0; i < weights.length; i++) {
                sum += weights[i];
                if (rand < sum) {
                    type = types[i];
                    break;
                }
            }
            
            let width, height;
            
            if (type === 'asteroid') {
                width = height = Math.random() * 50 + 40;
            } else if (type === 'satellite') {
                width = 40;
                height = 60;
            } else if (type === 'debris') {
                width = Math.random() * 30 + 20;
                height = Math.random() * 30 + 20;
            } else if (type === 'meteoroid') {
                width = height = Math.random() * 20 + 15;
            }

            const x = Math.random() * (canvas.width - width - 40) + 20;
            obstacles.push(new Obstacle(x, -height, width, height, type));
        }

        function drawRocket(x, y, type, width = 30, height = 60) {
            // Shadow/depth
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + height + 5, width/2, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw based on design type
            switch(type.design) {
                case 'sleek': // FALCON - modern SpaceX style
                    drawSleekRocket(x, y, type, width, height);
                    break;
                case 'heavy': // ATLAS - thick, powerful
                    drawHeavyRocket(x, y, type, width, height);
                    break;
                case 'racing': // DELTA - aerodynamic, fast
                    drawRacingRocket(x, y, type, width, height);
                    break;
                case 'cargo': // TITAN - wide, boxy
                    drawCargoRocket(x, y, type, width, height);
                    break;
                case 'euro': // ARIANE - elegant European design
                    drawEuroRocket(x, y, type, width, height);
                    break;
                case 'classic': // SOYUZ - Russian classic
                    drawClassicRocket(x, y, type, width, height);
                    break;
                case 'apollo': // SATURN - retro NASA
                    drawApolloRocket(x, y, type, width, height);
                    break;
                case 'modern': // ANTARES - contemporary
                    drawModernRocket(x, y, type, width, height);
                    break;
                case 'compact': // VEGA - small and nimble
                    drawCompactRocket(x, y, type, width, height);
                    break;
                case 'soviet': // PROTON - Soviet era
                    drawSovietRocket(x, y, type, width, height);
                    break;
                default:
                    drawSleekRocket(x, y, type, width, height);
            }
        }
        
        // SLEEK DESIGN - Modern SpaceX style
        function drawSleekRocket(x, y, type, width, height) {
            const bodyGradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
            bodyGradient.addColorStop(0, shadeColor(type.color, -20));
            bodyGradient.addColorStop(0.5, type.color);
            bodyGradient.addColorStop(1, shadeColor(type.color, -20));
            
            // Very pointed nose
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = shadeColor(type.color, -30);
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Grid fin style fins
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2 - 10, y + height - 15, 10, 12);
            ctx.fillRect(x + width/2, y + height - 15, 10, 12);
            
            // Grid pattern
            ctx.strokeStyle = shadeColor(type.accent, -30);
            ctx.lineWidth = 1;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x - width/2 - 10 + i*3, y + height - 15);
                ctx.lineTo(x - width/2 - 10 + i*3, y + height - 3);
                ctx.stroke();
            }

            // Minimal window
            ctx.fillStyle = '#00b4d8';
            ctx.fillRect(x - 6, y + 18, 12, 6);
            
            // Longitudinal stripe
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - 1, y + 10, 2, height - 15);
        }
        
        // HEAVY DESIGN - Thick and powerful
        function drawHeavyRocket(x, y, type, width, height) {
            width = width * 1.2; // Make it thicker
            
            // Blunt nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y + 8);
            ctx.lineTo(x - width/2, y + 20);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2, y + 20);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = shadeColor(type.color, -30);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Large boosters
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2 - 15, y + 30, 12, height - 30);
            ctx.fillRect(x + width/2 + 3, y + 30, 12, height - 30);
            ctx.strokeStyle = shadeColor(type.accent, -30);
            ctx.lineWidth = 1.5;
            ctx.strokeRect(x - width/2 - 15, y + 30, 12, height - 30);
            ctx.strokeRect(x + width/2 + 3, y + 30, 12, height - 30);
            
            // Multiple windows
            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            ctx.arc(x, y + 25, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Horizontal bands
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2, y + 40, width, 3);
            ctx.fillRect(x - width/2, y + 55, width, 3);
        }
        
        // RACING DESIGN - Aerodynamic and fast
        function drawRacingRocket(x, y, type, width, height) {
            width = width * 0.9; // Slimmer
            
            // Ultra sharp nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.closePath();
            ctx.fill();
            
            // Racing stripes
            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - 4, y + 5);
            ctx.lineTo(x - 6, y + height);
            ctx.lineTo(x - 3, y + height);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + 4, y + 5);
            ctx.lineTo(x + 6, y + height);
            ctx.lineTo(x + 3, y + height);
            ctx.closePath();
            ctx.fill();
            
            // Swept back fins
            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y + height - 15);
            ctx.lineTo(x - width/2 - 18, y + height + 3);
            ctx.lineTo(x - width/2 - 5, y + height);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + width/2, y + height - 15);
            ctx.lineTo(x + width/2 + 18, y + height + 3);
            ctx.lineTo(x + width/2 + 5, y + height);
            ctx.fill();
            
            // Sleek cockpit
            const cockpitGradient = ctx.createLinearGradient(x - 8, y + 15, x + 8, y + 15);
            cockpitGradient.addColorStop(0, '#014f86');
            cockpitGradient.addColorStop(0.5, '#00b4d8');
            cockpitGradient.addColorStop(1, '#014f86');
            ctx.fillStyle = cockpitGradient;
            ctx.fillRect(x - 8, y + 15, 16, 8);
        }
        
        // CARGO DESIGN - Wide and boxy
        function drawCargoRocket(x, y, type, width, height) {
            width = width * 1.3; // Much wider
            
            // Flat-ish nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x - 8, y + 5);
            ctx.lineTo(x - width/2, y + 15);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2, y + 15);
            ctx.lineTo(x + 8, y + 5);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = shadeColor(type.color, -30);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Cargo bay door lines
            ctx.strokeStyle = shadeColor(type.color, -40);
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x, y + 25);
            ctx.lineTo(x, y + height - 10);
            ctx.stroke();
            
            ctx.strokeStyle = type.accent;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - width/2 + 3, y + 30, width - 6, height - 40);
            
            // Small side windows
            ctx.fillStyle = '#00b4d8';
            ctx.fillRect(x - 10, y + 20, 4, 4);
            ctx.fillRect(x + 6, y + 20, 4, 4);
            
            // Stubby fins
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2 - 8, y + height - 20, 8, 20);
            ctx.fillRect(x + width/2, y + height - 20, 8, 20);
        }
        
        // EURO DESIGN - Elegant European
        function drawEuroRocket(x, y, type, width, height) {
            // Conical nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x - width/2, y + 15, x - width/2, y + 25);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2, y + 25);
            ctx.quadraticCurveTo(x + width/2, y + 15, x, y);
            ctx.closePath();
            ctx.fill();
            
            // Elegant stripes
            ctx.strokeStyle = type.accent;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - width/2 + 2, y + 35);
            ctx.lineTo(x + width/2 - 2, y + 35);
            ctx.stroke();
            
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - width/2 + 2, y + 42);
            ctx.lineTo(x + width/2 - 2, y + 42);
            ctx.stroke();
            
            // Symmetrical fins
            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y + height - 18);
            ctx.lineTo(x - width/2 - 12, y + height);
            ctx.lineTo(x - width/2, y + height);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + width/2, y + height - 18);
            ctx.lineTo(x + width/2 + 12, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.fill();
            
            // Round window
            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            ctx.arc(x, y + 22, 7, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // CLASSIC DESIGN - Russian Soyuz style
        function drawClassicRocket(x, y, type, width, height) {
            // Distinctive cone
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - width/2 + 2, y + 18);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2 - 2, y + 18);
            ctx.closePath();
            ctx.fill();
            
            // Classic ring pattern
            for(let i = 0; i < 4; i++) {
                const ringY = y + 28 + i * 10;
                ctx.strokeStyle = i % 2 === 0 ? type.accent : shadeColor(type.accent, 30);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - width/2, ringY);
                ctx.lineTo(x + width/2, ringY);
                ctx.stroke();
            }
            
            // Four strap-on boosters
            ctx.fillStyle = type.accent;
            const boosterPositions = [-width/2 - 8, -width/2 - 5, width/2 + 2, width/2 + 5];
            boosterPositions.forEach(pos => {
                ctx.fillRect(x + pos, y + 40, 3, height - 40);
            });
            
            // Small round window
            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            ctx.arc(x, y + 20, 5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // APOLLO DESIGN - Retro NASA
        function drawApolloRocket(x, y, type, width, height) {
            // Command module style nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y + 3);
            ctx.lineTo(x - width/2 + 3, y + 12);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2 - 3, y + 12);
            ctx.closePath();
            ctx.fill();
            
            // NASA-style bands
            ctx.fillStyle = '#c41e3a'; // NASA red
            ctx.fillRect(x - width/2, y + 25, width, 4);
            
            ctx.fillStyle = '#0b3d91'; // NASA blue
            ctx.fillRect(x - width/2, y + 38, width, 5);
            
            // USA text area
            ctx.fillStyle = type.color;
            ctx.fillRect(x - 8, y + 50, 16, 6);
            ctx.strokeStyle = shadeColor(type.color, -40);
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 8, y + 50, 16, 6);
            
            // Classic fins
            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y + height - 22);
            ctx.lineTo(x - width/2 - 14, y + height - 5);
            ctx.lineTo(x - width/2 - 14, y + height);
            ctx.lineTo(x - width/2, y + height);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + width/2, y + height - 22);
            ctx.lineTo(x + width/2 + 14, y + height - 5);
            ctx.lineTo(x + width/2 + 14, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.fill();
            
            // Round windows
            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            ctx.arc(x - 6, y + 17, 4, 0, Math.PI * 2);
            ctx.arc(x + 6, y + 17, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // MODERN DESIGN - Contemporary
        function drawModernRocket(x, y, type, width, height) {
            // Angular modern nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - width/2, y + 22);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2, y + 22);
            ctx.closePath();
            ctx.fill();
            
            // Diagonal accent stripes
            ctx.strokeStyle = type.accent;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(x - width/2 + 2, y + 30);
            ctx.lineTo(x + width/2 - 2, y + 40);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x - width/2 + 2, y + 48);
            ctx.lineTo(x + width/2 - 2, y + 58);
            ctx.stroke();
            
            // Modern angular fins
            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y + height - 20);
            ctx.lineTo(x - width/2 - 16, y + height - 8);
            ctx.lineTo(x - width/2 - 10, y + height);
            ctx.lineTo(x - width/2, y + height);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + width/2, y + height - 20);
            ctx.lineTo(x + width/2 + 16, y + height - 8);
            ctx.lineTo(x + width/2 + 10, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.fill();
            
            // Hexagonal window
            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            const hexSize = 6;
            for(let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const hx = x + hexSize * Math.cos(angle);
                const hy = y + 20 + hexSize * Math.sin(angle);
                if(i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        // COMPACT DESIGN - Small and nimble
        function drawCompactRocket(x, y, type, width, height) {
            width = width * 0.8; // Smaller
            height = height * 0.9;
            
            // Sharp compact nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y - 3);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.closePath();
            ctx.fill();
            
            // Single bold stripe
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2 + 1, y + 25, width - 2, 4);
            
            // Tiny fins
            ctx.fillStyle = type.accent;
            ctx.beginPath();
            ctx.moveTo(x - width/2, y + height - 12);
            ctx.lineTo(x - width/2 - 10, y + height);
            ctx.lineTo(x - width/2, y + height);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(x + width/2, y + height - 12);
            ctx.lineTo(x + width/2 + 10, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.fill();
            
            // Small oval window
            ctx.fillStyle = '#00b4d8';
            ctx.beginPath();
            ctx.ellipse(x, y + 18, 5, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Compact engine details
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(x - width/3, y + height, width * 2/3, 3);
        }
        
        // SOVIET DESIGN - Soviet era style
        function drawSovietRocket(x, y, type, width, height) {
            // Bulbous nose
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(x, y + 2);
            ctx.quadraticCurveTo(x - width/2 - 2, y + 12, x - width/2, y + 20);
            ctx.lineTo(x - width/2, y + height);
            ctx.lineTo(x + width/2, y + height);
            ctx.lineTo(x + width/2, y + 20);
            ctx.quadraticCurveTo(x + width/2 + 2, y + 12, x, y + 2);
            ctx.closePath();
            ctx.fill();
            
            // Thick horizontal bands
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2, y + 32, width, 5);
            ctx.fillRect(x - width/2, y + 45, width, 5);
            ctx.fillRect(x - width/2, y + 58, width, 5);
            
            // Rivets
            ctx.fillStyle = shadeColor(type.color, -50);
            for(let i = 0; i < 5; i++) {
                const rivetY = y + 35 + i * 8;
                ctx.beginPath();
                ctx.arc(x - width/2 + 2, rivetY, 1.5, 0, Math.PI * 2);
                ctx.arc(x + width/2 - 2, rivetY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Robust fins
            ctx.fillStyle = type.accent;
            ctx.fillRect(x - width/2 - 11, y + height - 18, 11, 18);
            ctx.fillRect(x + width/2, y + height - 18, 11, 18);
            ctx.strokeStyle = shadeColor(type.accent, -30);
            ctx.lineWidth = 1.5;
            ctx.strokeRect(x - width/2 - 11, y + height - 18, 11, 18);
            ctx.strokeRect(x + width/2, y + height - 18, 11, 18);
            
            // Square window
            ctx.fillStyle = '#00b4d8';
            ctx.fillRect(x - 5, y + 20, 10, 8);
        }
        
        // Helper function to shade colors
        function shadeColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function gameOver(reason = 'crashed') {
            if (gameState === 'gameOver') return;
            
            gameState = 'gameOver';
            
            // Add player to finish order if not already there
            if (!rocket.finished && !finishOrder.find(r => r.isPlayer)) {
                finishOrder.push({
                    name: 'YOU (' + rocket.type.name + ')',
                    distance: rocket.distance,
                    finished: reason === 'finished',
                    isPlayer: true,
                    finishTime: reason === 'finished' ? gameTime : null
                });
            }
            
            // Add remaining bots to finish order
            bots.forEach(bot => {
                if (!finishOrder.find(r => r.name === bot.name)) {
                    finishOrder.push({
                        name: bot.name,
                        distance: bot.distance,
                        finished: bot.finished,
                        isPlayer: false,
                        finishTime: bot.finishTime
                    });
                }
            });
            
            // Sort by finished first, then by finish time or distance
            finishOrder.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                if (a.finished && b.finished) return a.finishTime - b.finishTime;
                return b.distance - a.distance;
            });
            
            // Find player rank
            const rank = finishOrder.findIndex(r => r.isPlayer) + 1;
            
            // Update UI
            document.getElementById('rank').textContent = rank;
            document.getElementById('finalDistance').textContent = Math.floor(rocket.distance);
            
            const title = document.getElementById('gameOverTitle');
            const status = document.getElementById('gameOverStatus');
            
            if (reason === 'finished') {
                title.textContent = 'ðŸ RACE COMPLETE! ðŸ';
                title.style.color = '#06ffa5';
                status.textContent = 'You finished the race!';
                status.style.color = '#06ffa5';
            } else if (reason === 'crashed') {
                title.textContent = 'ðŸ’¥ CRASHED! ðŸ’¥';
                title.style.color = '#ff006e';
                status.textContent = 'You collided with an obstacle or another rocket!';
                status.style.color = '#ff006e';
            } else if (reason === 'fuel') {
                title.textContent = 'â›½ OUT OF FUEL! â›½';
                title.style.color = '#ffc300';
                status.textContent = 'Your rocket ran out of fuel!';
                status.style.color = '#ffc300';
            }
            
            // Display results table
            const resultsTable = document.getElementById('resultsTable');
            resultsTable.innerHTML = '';
            finishOrder.forEach((result, index) => {
                const row = document.createElement('div');
                row.className = 'result-row';
                if (result.isPlayer) row.classList.add('player');
                if (result.finished) row.classList.add('finished');
                else row.classList.add('crashed');
                
                const statusText = result.finished ? 'âœ“ ' + Math.floor(result.finishTime/60) + 's' : 'âœ— ' + Math.floor(result.distance) + 'm';
                row.innerHTML = `<span>${index + 1}. ${result.name}</span><span>${statusText}</span>`;
                resultsTable.appendChild(row);
            });
            
            document.getElementById('gameOver').style.display = 'block';
        }

        function updateBots() {
            bots.forEach(bot => {
                if (!bot.alive || bot.finished) return;
                
                bot.aiTimer++;
                
                // Bots move upward at their own speed
                const botSpeed = scrollSpeed * bot.personality.speedVariance;
                bot.distance += botSpeed;
                bot.y -= (botSpeed - scrollSpeed); // Move relative to screen
                
                // Check if finished
                if (bot.distance >= TARGET_ALTITUDE) {
                    bot.finished = true;
                    bot.finishTime = gameTime;
                    finishOrder.push({
                        name: bot.name,
                        distance: bot.distance,
                        finished: true,
                        isPlayer: false,
                        finishTime: gameTime
                    });
                    return;
                }
                
                // Advanced AI with personality - smarter obstacle prediction
                if (bot.aiTimer % 15 === 0) {
                    let nearestDanger = null;
                    let minDangerDist = Infinity;
                    let dangerType = null;
                    
                    // Predict future position of obstacles
                    obstacles.forEach(obs => {
                        // Calculate where obstacle will be in next few frames
                        const futureObsY = obs.y + scrollSpeed * 10;
                        const futureObsX = obs.x;
                        
                        // Calculate where bot will be
                        const futureBotY = bot.y - (scrollSpeed * bot.personality.speedVariance - scrollSpeed) * 10;
                        
                        const dist = Math.sqrt(Math.pow(futureObsX - bot.x, 2) + Math.pow(futureObsY - futureBotY, 2));
                        
                        // Check if obstacle is in predicted path
                        const isAhead = obs.y > bot.y - 400 && obs.y < bot.y + 50;
                        const horizontalDist = Math.abs(obs.x - bot.x);
                        const willCollide = horizontalDist < (obs.width/2 + bot.width/2 + 40);
                        
                        if (isAhead && willCollide && dist < minDangerDist) {
                            minDangerDist = dist;
                            nearestDanger = { x: obs.x, width: obs.width, y: obs.y };
                            dangerType = 'obstacle';
                        }
                    });
                    
                    // Check for rocket collisions
                    const checkRocket = (otherRocket) => {
                        if (!otherRocket.alive || otherRocket.finished) return;
                        
                        const dist = Math.sqrt(Math.pow(otherRocket.x - bot.x, 2) + Math.pow(otherRocket.y - bot.y, 2));
                        const horizontalDist = Math.abs(otherRocket.x - bot.x);
                        const willCollide = horizontalDist < 80 && Math.abs(otherRocket.y - bot.y) < 150;
                        
                        if (willCollide && dist < minDangerDist) {
                            minDangerDist = dist;
                            nearestDanger = { x: otherRocket.x, width: 60, y: otherRocket.y };
                            dangerType = 'rocket';
                        }
                    };
                    
                    // Check player
                    if (rocket.alive && !rocket.finished) {
                        checkRocket(rocket);
                    }
                    
                    // Check other bots
                    bots.forEach(otherBot => {
                        if (otherBot !== bot) {
                            checkRocket(otherBot);
                        }
                    });
                    
                    // Smart decision making
                    if (nearestDanger) {
                        const shouldReact = dangerType === 'obstacle' ? 
                            Math.random() < bot.personality.dodgeChance : 
                            Math.random() < bot.personality.collisionAvoidance;
                        
                        if (shouldReact) {
                            // Calculate best dodge direction
                            const leftSpace = nearestDanger.x - nearestDanger.width/2 - bot.width/2;
                            const rightSpace = canvas.width - (nearestDanger.x + nearestDanger.width/2) - bot.width/2;
                            
                            let dodgeDirection;
                            if (bot.x < nearestDanger.x) {
                                // We're on left side - should we go left or right?
                                dodgeDirection = (leftSpace > 80 || rightSpace < 80) ? -1 : 1;
                            } else {
                                // We're on right side
                                dodgeDirection = (rightSpace > 80 || leftSpace < 80) ? 1 : -1;
                            }
                            
                            // Set dodge target based on urgency
                            const urgency = Math.max(0, 1 - minDangerDist / 200);
                            const dodgeAmount = 80 + urgency * 70;
                            bot.targetX = bot.x + (dodgeDirection * dodgeAmount);
                        }
                    } else {
                        // No immediate danger - strategic movement
                        const moveChance = bot.aggressiveness > 0.7 ? 0.4 : 
                                          bot.aggressiveness < 0.3 ? 0.1 : 0.2;
                        
                        if (Math.random() < moveChance) {
                            if (bot.aggressiveness > 0.7) {
                                // Aggressive - weave for overtaking
                                bot.targetX = bot.x + (Math.random() - 0.5) * 150;
                            } else if (bot.aggressiveness < 0.3) {
                                // Conservative - small adjustments to stay centered
                                const centerX = canvas.width / 2;
                                bot.targetX = bot.x + (centerX - bot.x) * 0.1 + (Math.random() - 0.5) * 40;
                            } else {
                                // Balanced
                                bot.targetX = bot.x + (Math.random() - 0.5) * 100;
                            }
                        }
                    }
                    
                    // Clamp target to safe screen bounds
                    bot.targetX = Math.max(60, Math.min(canvas.width - 60, bot.targetX));
                }
                
                // Smooth movement with acceleration/deceleration
                if (bot.fuel > 0 && bot.alive) {
                    const distToTarget = bot.targetX - bot.x;
                    const maxSpeed = bot.speed * 0.5; // Maximum turning speed
                    const acceleration = 0.15; // How quickly they speed up/slow down
                    
                    if (Math.abs(distToTarget) > 3) {
                        // Accelerate towards target
                        const targetVelocity = Math.sign(distToTarget) * Math.min(Math.abs(distToTarget) * 0.1, maxSpeed);
                        bot.velocityX += (targetVelocity - bot.velocityX) * acceleration;
                    } else {
                        // Decelerate when close to target
                        bot.velocityX *= 0.9;
                    }
                    
                    // Apply velocity
                    bot.x += bot.velocityX;
                    
                    // Use fuel based on how much we're turning
                    bot.fuel -= Math.abs(bot.velocityX) * 0.02;
                    
                    // Keep bot on screen
                    if (bot.x < bot.width/2) {
                        bot.x = bot.width/2;
                        bot.velocityX = 0;
                    }
                    if (bot.x > canvas.width - bot.width/2) {
                        bot.x = canvas.width - bot.width/2;
                        bot.velocityX = 0;
                    }
                } else if (bot.fuel <= 0) {
                    bot.alive = false;
                }
                
                // Check collisions with obstacles
                obstacles.forEach(obs => {
                    const botHitbox = {
                        x: bot.x - bot.width/2,
                        y: bot.y,
                        width: bot.width,
                        height: bot.height
                    };
                    
                    if (checkCollision(botHitbox, obs)) {
                        bot.alive = false;
                    }
                });
                
                // Check collisions with other rockets
                if (rocket.alive && !rocket.finished) {
                    const rocketHitbox = {
                        x: rocket.x - rocket.width/2,
                        y: rocket.y,
                        width: rocket.width,
                        height: rocket.height
                    };
                    const botHitbox = {
                        x: bot.x - bot.width/2,
                        y: bot.y,
                        width: bot.width,
                        height: bot.height
                    };
                    
                    if (checkCollision(rocketHitbox, botHitbox)) {
                        bot.alive = false;
                        rocket.alive = false;
                        gameOver('crashed');
                    }
                }
                
                // Check collisions between bots
                bots.forEach(otherBot => {
                    if (otherBot !== bot && otherBot.alive && !otherBot.finished) {
                        const botHitbox1 = {
                            x: bot.x - bot.width/2,
                            y: bot.y,
                            width: bot.width,
                            height: bot.height
                        };
                        const botHitbox2 = {
                            x: otherBot.x - otherBot.width/2,
                            y: otherBot.y,
                            width: otherBot.width,
                            height: otherBot.height
                        };
                        
                        if (checkCollision(botHitbox1, botHitbox2)) {
                            bot.alive = false;
                            otherBot.alive = false;
                        }
                    }
                });
                
                // Particles
                if (Math.random() < 0.3 && bot.fuel > 0) {
                    particles.push(new Particle(bot.x, bot.y + bot.height, 
                        bot.type.accent, '#ffc300'));
                }
            });
        }

        function update() {
            if (gameState === 'flying') {
                gameTime++;
                
                // Update rocket position
                rocket.dx = 0;
                rocket.dy = 0;

                if (rocket.alive && !rocket.finished) {
                    if ((keys['ArrowLeft'] || keys['a'] || keys['A']) && rocket.fuel > 0) {
                        rocket.dx = -rocket.speed;
                        rocket.fuel -= 0.1;
                    }
                    if ((keys['ArrowRight'] || keys['d'] || keys['D']) && rocket.fuel > 0) {
                        rocket.dx = rocket.speed;
                        rocket.fuel -= 0.1;
                    }
                    if ((keys['ArrowUp'] || keys['w'] || keys['W']) && rocket.fuel > 0) {
                        rocket.dy = -rocket.speed;
                        rocket.fuel -= 0.15;
                    }
                    if ((keys['ArrowDown'] || keys['s'] || keys['S']) && rocket.fuel > 0) {
                        rocket.dy = rocket.speed;
                        rocket.fuel -= 0.1;
                    }

                    rocket.x += rocket.dx;
                    rocket.y += rocket.dy;

                    // Keep rocket on screen horizontally
                    if (rocket.x - rocket.width/2 < 0) rocket.x = rocket.width/2;
                    if (rocket.x + rocket.width/2 > canvas.width) rocket.x = canvas.width - rocket.width/2;
                    
                    // Soft vertical boundaries - allow going slightly off screen but keep mostly visible
                    if (rocket.y < -rocket.height/2) rocket.y = -rocket.height/2; // Can go half off top
                    if (rocket.y + rocket.height > canvas.height + rocket.height/2) rocket.y = canvas.height - rocket.height/2; // Can go half off bottom

                    altitude += scrollSpeed;
                    rocket.distance += scrollSpeed;
                    score += Math.floor(scrollSpeed);
                    scrollSpeed += 0.001;

                    // Check if finished
                    if (rocket.distance >= TARGET_ALTITUDE) {
                        rocket.finished = true;
                        rocket.finishTime = gameTime;
                        finishOrder.push({
                            name: 'YOU (' + rocket.type.name + ')',
                            distance: rocket.distance,
                            finished: true,
                            isPlayer: true,
                            finishTime: gameTime
                        });
                        gameOver('finished');
                        return;
                    }

                    if (Math.random() < 0.5 && rocket.fuel > 0) {
                        particles.push(new Particle(rocket.x, rocket.y + rocket.height,
                            rocket.type.accent, '#ffc300'));
                    }
                }

                updateBots();

                particles = particles.filter(p => {
                    p.update();
                    return p.life > 0;
                });

                obstacleSpawnTimer++;
                if (obstacleSpawnTimer > 60 / scrollSpeed) {
                    spawnObstacle();
                    obstacleSpawnTimer = 0;
                }

                obstacles = obstacles.filter(obs => {
                    obs.update();
                    
                    if (rocket.alive && !rocket.finished) {
                        const rocketHitbox = {
                            x: rocket.x - rocket.width/2,
                            y: rocket.y,
                            width: rocket.width,
                            height: rocket.height
                        };
                        
                        if (checkCollision(rocketHitbox, obs)) {
                            rocket.alive = false;
                            gameOver('crashed');
                        }
                    }

                    return obs.y < canvas.height + 100;
                });

                // Calculate position
                let position = 1;
                bots.forEach(bot => {
                    if ((bot.finished && !rocket.finished) || (bot.distance > rocket.distance && bot.alive)) {
                        position++;
                    }
                });

                // Count alive rockets
                let aliveCount = (rocket.alive && !rocket.finished) ? 1 : 0;
                bots.forEach(bot => {
                    if (bot.alive && !bot.finished) aliveCount++;
                });

                document.getElementById('altitude').textContent = Math.floor(altitude);
                document.getElementById('speed').textContent = (scrollSpeed * 10).toFixed(1);
                document.getElementById('fuel').textContent = Math.max(0, rocket.fuel).toFixed(0);
                document.getElementById('position').textContent = position;
                document.getElementById('aliveCount').textContent = aliveCount;

                if (rocket.fuel <= 0 && rocket.alive && !rocket.finished) {
                    rocket.alive = false;
                    gameOver('fuel');
                }
            }
        }

        function drawBackground() {
            backgroundOffset += scrollSpeed * 0.5;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 150; i++) {
                const x = (i * 97) % canvas.width;
                const y = ((i * 137 + backgroundOffset) % canvas.height);
                const size = (i % 3) + 1;
                ctx.fillRect(x, y, size, size);
            }
        }

        function drawLaunchPads() {
            if (gameState === 'launch') {
                launchPads.forEach(pad => {
                    ctx.fillStyle = pad.isPlayer ? '#ffc300' : '#003566';
                    ctx.strokeStyle = pad.isPlayer ? '#ff006e' : '#00b4d8';
                    ctx.lineWidth = 2;
                    ctx.fillRect(pad.x - 25, pad.y, 50, 10);
                    ctx.strokeRect(pad.x - 25, pad.y, 50, 10);
                    
                    ctx.strokeStyle = pad.isPlayer ? '#ffc300' : '#00b4d8';
                    ctx.beginPath();
                    ctx.moveTo(pad.x - 20, pad.y + 10);
                    ctx.lineTo(pad.x - 15, pad.y + 30);
                    ctx.moveTo(pad.x + 20, pad.y + 10);
                    ctx.lineTo(pad.x + 15, pad.y + 30);
                    ctx.stroke();
                });
            }
        }

        function drawFinishLine() {
            if (gameState === 'flying') {
                const finishY = canvas.height - (rocket.distance / TARGET_ALTITUDE) * canvas.height * 10;
                
                if (finishY > -50 && finishY < canvas.height + 50) {
                    ctx.strokeStyle = '#06ffa5';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([20, 10]);
                    ctx.beginPath();
                    ctx.moveTo(0, finishY);
                    ctx.lineTo(canvas.width, finishY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = '#06ffa5';
                    ctx.font = 'bold 20px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('FINISH LINE', canvas.width / 2, finishY - 10);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            drawLaunchPads();
            drawFinishLine();

            particles.forEach(p => p.draw());
            obstacles.forEach(obs => obs.draw());

            bots.forEach(bot => {
                if ((bot.alive || gameState === 'launch') && !bot.finished) {
                    drawRocket(bot.x, bot.y, bot.type);
                }
            });

            if ((rocket.type && (rocket.alive || gameState === 'launch') && !rocket.finished)) {
                drawRocket(rocket.x, rocket.y, rocket.type);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        createRocketSelection();
        gameLoop();
    </script>
</body>
</html>